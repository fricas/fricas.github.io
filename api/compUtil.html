<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>compUtil UT &mdash; FriCAS 1.2.3 API</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="FriCAS 1.2.3 API" href="../index.html" />
    <link rel="up" title="Packages" href="Packages.html" />
    <link rel="next" title="ConstantLinearDependence(R, ld)" href="ConstantLinearDependence.html" />
    <link rel="prev" title="ComplexTrigonometricManipulations(R, F)" href="ComplexTrigonometricManipulations.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="ConstantLinearDependence.html" title="ConstantLinearDependence(R, ld)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="ComplexTrigonometricManipulations.html" title="ComplexTrigonometricManipulations(R, F)"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">FriCAS 1.2.3 API</a> &raquo;</li>
          <li><a href="index.html" >FriCAS</a> &raquo;</li>
          <li><a href="Packages.html" accesskey="U">Packages</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="computil-ut">
<span id="l-comp-util"></span><span id="index-0"></span><h1>compUtil UT<a class="headerlink" href="#computil-ut" title="Permalink to this headline">Â¶</a></h1>
<p><a class="reference external" href="https://github.com/fricas/fricas/blob/master/src/algebra//computation.spad#L3066">computation.spad line 3066</a></p>
<ul class="simple">
<li>UT: <a class="reference internal" href="VarCat.html#l-var-cat"><em>VarCat</em></a></li>
</ul>
<p>The compUtil package provides utilities to convert between the computational domains: Lambda, Ski and ILogic. Both Lambda are Ski are Turing complete and can be coerced to each other. Lambda and Ski are not equal and they are only isomorphic up to beta-equivalence and beta-equivalence is undecidable so there is not a direct correspondence between the nodes in their trees. Also the names of bound variables and other such constructions may be lost in Lambda <tt class="docutils literal"><span class="pre">-&gt;</span></tt> Ski <tt class="docutils literal"><span class="pre">-&gt;</span></tt> Lambda round trip. An element of ILogic cannot be coerced to the other types. However ILogic can be used to produce a theory which can be concerted to/from the other domains using Curry-Howard isomorphism.</p>
<span class="target" id="l-comp-util-coerce"></span><dl class="docutils" id="index-1">
<dt><span class="spadfun">coerce</span>: <a class="reference internal" href="Lambda.html#l-lambda"><em>Lambda</em></a> UT -&gt; <a class="reference internal" href="SKICombinators.html#l-s-k-i-combinators"><em>SKICombinators</em></a> UT</dt>
<dd><tt class="docutils literal"><span class="pre">coerce</span> <span class="pre">Lambda</span></tt> term to SKI combinators. this process is known as abstraction elimination. it is done by applying the following rules until all lambda terms have been eliminated. rule LS1: Lam[<tt class="docutils literal"><span class="pre">x</span></tt>] <tt class="docutils literal"><span class="pre">=&gt;</span></tt> <tt class="docutils literal"><span class="pre">x</span></tt> rule LS2: Lam[(<tt class="docutils literal"><span class="pre">E1</span></tt> <tt class="docutils literal"><span class="pre">E2</span></tt>)] <tt class="docutils literal"><span class="pre">=&gt;</span></tt> (Lam[<tt class="docutils literal"><span class="pre">E1</span></tt>] Lam[<tt class="docutils literal"><span class="pre">E2</span></tt>]) rule LS3: Lam[<tt class="docutils literal"><span class="pre">\x</span></tt>.<tt class="docutils literal"><span class="pre">E</span></tt>] <tt class="docutils literal"><span class="pre">=&gt;</span></tt> (<tt class="docutils literal"><span class="pre">K</span></tt> Lam[<tt class="docutils literal"><span class="pre">E</span></tt>]) (if <tt class="docutils literal"><span class="pre">x</span></tt> does not occur free in <tt class="docutils literal"><span class="pre">E</span></tt>) rule LS4: Lam[<tt class="docutils literal"><span class="pre">\x</span></tt>.<tt class="docutils literal"><span class="pre">x</span></tt>] <tt class="docutils literal"><span class="pre">=&gt;</span></tt> <tt class="docutils literal"><span class="pre">I</span></tt> rule LS5: Lam[<tt class="docutils literal"><span class="pre">\x</span></tt>.y.<tt class="docutils literal"><span class="pre">E</span></tt>] <tt class="docutils literal"><span class="pre">=&gt;</span></tt> Lam[<tt class="docutils literal"><span class="pre">\x</span></tt>.Lam[y.<tt class="docutils literal"><span class="pre">E</span></tt>]] (if <tt class="docutils literal"><span class="pre">x</span></tt> occurs free in <tt class="docutils literal"><span class="pre">E</span></tt>) rule LS6: Lam[<tt class="docutils literal"><span class="pre">\x</span></tt>.(<tt class="docutils literal"><span class="pre">E1</span></tt> <tt class="docutils literal"><span class="pre">E2</span></tt>)] <tt class="docutils literal"><span class="pre">=&gt;</span></tt> (<tt class="docutils literal"><span class="pre">S</span></tt> Lam[<tt class="docutils literal"><span class="pre">\x</span></tt>.<tt class="docutils literal"><span class="pre">E1</span></tt>] Lam[<tt class="docutils literal"><span class="pre">\x</span></tt>.<tt class="docutils literal"><span class="pre">E2</span></tt>])</dd>
</dl>
<dl class="docutils" id="index-2">
<dt><span class="spadfun">coerce</span>: <a class="reference internal" href="SKICombinators.html#l-s-k-i-combinators"><em>SKICombinators</em></a> UT -&gt; <a class="reference internal" href="ILogic.html#l-i-logic"><em>ILogic</em></a></dt>
<dd><tt class="docutils literal"><span class="pre">coerce</span> <span class="pre">combinators</span></tt> to intuitionistic logic this is known as the Curry-Howard isomorphism it uses the following rules: rule SI1: Ski[Kab] <tt class="docutils literal"><span class="pre">=&gt;</span></tt> a <tt class="docutils literal"><span class="pre">-&gt;</span></tt> (<tt class="docutils literal"><span class="pre">b</span></tt> <tt class="docutils literal"><span class="pre">-&gt;</span></tt> a), rule SI2: Ski[Sabc] <tt class="docutils literal"><span class="pre">=&gt;</span></tt> (a <tt class="docutils literal"><span class="pre">-&gt;</span></tt> (<tt class="docutils literal"><span class="pre">b</span></tt> <tt class="docutils literal"><span class="pre">-&gt;</span></tt> <tt class="docutils literal"><span class="pre">c</span></tt>)) <tt class="docutils literal"><span class="pre">-&gt;</span></tt> ((a <tt class="docutils literal"><span class="pre">-&gt;</span></tt> <tt class="docutils literal"><span class="pre">b</span></tt>) <tt class="docutils literal"><span class="pre">-&gt;</span></tt> (a <tt class="docutils literal"><span class="pre">-&gt;</span></tt> <tt class="docutils literal"><span class="pre">c</span></tt>)), rule SI3: Ski[a a-<tt class="docutils literal"><span class="pre">&gt;b</span></tt>] <tt class="docutils literal"><span class="pre">=&gt;</span></tt> <tt class="docutils literal"><span class="pre">b</span></tt> the last rule is function application (modus ponens)</dd>
</dl>
<dl class="docutils" id="index-3">
<dt><span class="spadfun">coerce</span>: <a class="reference internal" href="SKICombinators.html#l-s-k-i-combinators"><em>SKICombinators</em></a> UT -&gt; <a class="reference internal" href="Lambda.html#l-lambda"><em>Lambda</em></a> UT</dt>
<dd><tt class="docutils literal"><span class="pre">coerce</span> <span class="pre">SKI</span></tt> combinators to Lambda term. this conversion is done by applying the following rules rule SL1: Ski[<tt class="docutils literal"><span class="pre">I</span></tt>] = <tt class="docutils literal"><span class="pre">\x</span></tt>.0 rule SL2: Ski[<tt class="docutils literal"><span class="pre">K</span></tt>] = <tt class="docutils literal"><span class="pre">\x</span></tt>.y.1 rule SL3: Ski[<tt class="docutils literal"><span class="pre">S</span></tt>] = <tt class="docutils literal"><span class="pre">\x</span></tt>.y.<tt class="docutils literal"><span class="pre">\z</span></tt>.(2 0 (1 0)) rule SL4: Ski[(<tt class="docutils literal"><span class="pre">E1</span></tt> <tt class="docutils literal"><span class="pre">E2</span></tt>)] = (Ski[<tt class="docutils literal"><span class="pre">E1</span></tt>] Ski[<tt class="docutils literal"><span class="pre">E2</span></tt>])</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">FriCAS</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Categories.html">Categories</a></li>
<li class="toctree-l2"><a class="reference internal" href="Domains.html">Domains</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="Packages.html">Packages</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/api/compUtil.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="ConstantLinearDependence.html" title="ConstantLinearDependence(R, ld)"
             >next</a> |</li>
        <li class="right" >
          <a href="ComplexTrigonometricManipulations.html" title="ComplexTrigonometricManipulations(R, F)"
             >previous</a> |</li>
        <li><a href="../index.html">FriCAS 1.2.3 API</a> &raquo;</li>
          <li><a href="index.html" >FriCAS</a> &raquo;</li>
          <li><a href="Packages.html" >Packages</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, FriCAS Team.
      Last updated on Jun 13, 2014.
    </div>
  </body>
</html>