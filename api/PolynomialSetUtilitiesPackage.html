<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>PolynomialSetUtilitiesPackage(R, E, V, P) &#8212; FriCAS</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=2bf1fcf8" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    
    <script src="../_static/documentation_options.js?v=93b43ced"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="PolynomialSolveByFormulas(UP, F, RR)" href="PolynomialSolveByFormulas.html" />
    <link rel="prev" title="PolynomialRoots(E, V, R, P, F)" href="PolynomialRoots.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="PolynomialSolveByFormulas.html" title="PolynomialSolveByFormulas(UP, F, RR)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="PolynomialRoots.html" title="PolynomialRoots(E, V, R, P, F)"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">FriCAS</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >FriCAS API</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="Packages.html" accesskey="U">Packages</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">PolynomialSetUtilitiesPackage(R, E, V, P)</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="polynomialsetutilitiespackage-r-e-v-p">
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765"></span><span id="index-0"></span><h1>PolynomialSetUtilitiesPackage(R, E, V, P)<a class="headerlink" href="#polynomialsetutilitiespackage-r-e-v-p" title="Link to this heading">Â¶</a></h1>
<p><a class="extlink-viewcode reference external" href="https://github.com/fricas/fricas/blob/master/src/algebra/triset.spad#L587">triset.spad line 587</a> <a class="extlink-editcode reference external" href="https://github.com/fricas/fricas/edit/master/src/algebra/triset.spad#L587">[edit on github]</a></p>
<ul class="simple">
<li><p>R: <a class="reference internal" href="IntegralDomain.html#l496e74656772616c446f6d61696e"><span class="std std-ref">IntegralDomain</span></a></p></li>
<li><p>E: <a class="reference internal" href="OrderedAbelianMonoidSup.html#l4f7264657265644162656c69616e4d6f6e6f6964537570"><span class="std std-ref">OrderedAbelianMonoidSup</span></a></p></li>
<li><p>V: <a class="reference internal" href="OrderedSet.html#l4f726465726564536574"><span class="std std-ref">OrderedSet</span></a></p></li>
<li><p>P: <a class="reference internal" href="RecursivePolynomialCategory.html#l526563757273697665506f6c796e6f6d69616c43617465676f7279"><span class="std std-ref">RecursivePolynomialCategory</span></a>(R, E, V)</p></li>
</ul>
<p>This package provides modest routines for polynomial system solving. The aim of many of the operations of this package is to remove certain factors in some polynomials in order to avoid unnecessary computations in algorithms involving splitting techniques by partial factorization.</p>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-6269766172696174653f"></span><dl class="simple" id="index-1">
<dt><span class="spadfun">bivariate?</span>: P -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">bivariate?(p)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff <code class="docutils literal notranslate"><span class="pre">p</span></code> involves two and only two variables.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-626976617269617465506f6c796e6f6d69616c73"></span><dl class="simple" id="index-2">
<dt><span class="spadfun">bivariatePolynomials</span>: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P -&gt; Record(goodPols: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, badPols: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">bivariatePolynomials(lp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">bps,</span> <span class="pre">nbps</span></code> where <code class="docutils literal notranslate"><span class="pre">bps</span></code> is a list of the bivariate polynomials, and <code class="docutils literal notranslate"><span class="pre">nbps</span></code> are the other ones.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-6365727461696e6c79537562566172696574793f"></span><dl class="simple" id="index-3">
<dt><span class="spadfun">certainlySubVariety?</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P) -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">certainlySubVariety?(newlp,</span> <span class="pre">lp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff for every <code class="docutils literal notranslate"><span class="pre">p</span></code> in <code class="docutils literal notranslate"><span class="pre">lp</span></code> the remainder of <code class="docutils literal notranslate"><span class="pre">p</span></code> by <code class="docutils literal notranslate"><span class="pre">newlp</span></code> using the division algorithm of Groebner techniques is zero.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-63727573686564536574"></span><dl class="simple" id="index-4">
<dt><span class="spadfun">crushedSet</span>: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">crushedSet(lp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">lq</span></code> such that <code class="docutils literal notranslate"><span class="pre">lp</span></code> and and <code class="docutils literal notranslate"><span class="pre">lq</span></code> generate the same ideal and no rough basic sets reduce (in the sense of Groebner bases) the other polynomials in <code class="docutils literal notranslate"><span class="pre">lq</span></code>.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-696e746572526564756365"></span><dl class="simple" id="index-5">
<dt><span class="spadfun">interReduce</span>: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">interReduce(lp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">lq</span></code> such that <code class="docutils literal notranslate"><span class="pre">lp</span></code> and <code class="docutils literal notranslate"><span class="pre">lq</span></code> generate the same ideal and no polynomial in <code class="docutils literal notranslate"><span class="pre">lq</span></code> is reducible by the others in the sense of Groebner bases. Since no assumptions are required the result may depend on the ordering the reductions are performed.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-6972726564756369626c65466163746f7273"></span><dl class="simple" id="index-6">
<dt><span class="spadfun">irreducibleFactors</span>: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P if R has <a class="reference internal" href="PolynomialFactorizationExplicit.html#l506f6c796e6f6d69616c466163746f72697a6174696f6e4578706c69636974"><span class="std std-ref">PolynomialFactorizationExplicit</span></a> and R has <a class="reference internal" href="CharacteristicZero.html#l43686172616374657269737469635a65726f"><span class="std std-ref">CharacteristicZero</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">irreducibleFactors(lp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">lf</span></code> such that if <code class="docutils literal notranslate"><span class="pre">lp</span> <span class="pre">=</span> <span class="pre">[p1,</span> <span class="pre">...,</span> <span class="pre">pn]</span></code> and <code class="docutils literal notranslate"><span class="pre">lf</span> <span class="pre">=</span> <span class="pre">[f1,</span> <span class="pre">...,</span> <span class="pre">fm]</span></code> then <code class="docutils literal notranslate"><span class="pre">p1*p2*...*pn=0</span></code> means <code class="docutils literal notranslate"><span class="pre">f1*f2*...*fm=0</span></code>, and the <code class="docutils literal notranslate"><span class="pre">fi</span></code> are irreducible over <code class="docutils literal notranslate"><span class="pre">R</span></code> and are pairwise distinct.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-6c617a794972726564756369626c65466163746f7273"></span><dl class="simple" id="index-7">
<dt><span class="spadfun">lazyIrreducibleFactors</span>: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P if R has <a class="reference internal" href="PolynomialFactorizationExplicit.html#l506f6c796e6f6d69616c466163746f72697a6174696f6e4578706c69636974"><span class="std std-ref">PolynomialFactorizationExplicit</span></a> and R has <a class="reference internal" href="CharacteristicZero.html#l43686172616374657269737469635a65726f"><span class="std std-ref">CharacteristicZero</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">lazyIrreducibleFactors(lp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">lf</span></code> such that if <code class="docutils literal notranslate"><span class="pre">lp</span> <span class="pre">=</span> <span class="pre">[p1,</span> <span class="pre">...,</span> <span class="pre">pn]</span></code> and <code class="docutils literal notranslate"><span class="pre">lf</span> <span class="pre">=</span> <span class="pre">[f1,</span> <span class="pre">...,</span> <span class="pre">fm]</span></code> then <code class="docutils literal notranslate"><span class="pre">p1*p2*...*pn=0</span></code> means <code class="docutils literal notranslate"><span class="pre">f1*f2*...*fm=0</span></code>, and the <code class="docutils literal notranslate"><span class="pre">fi</span></code> are irreducible over <code class="docutils literal notranslate"><span class="pre">R</span></code> and are pairwise distinct. The algorithm tries to avoid factorization into irreducible factors as far as possible and makes previously use of <code class="docutils literal notranslate"><span class="pre">gcd</span></code> techniques over <code class="docutils literal notranslate"><span class="pre">R</span></code>.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-6c696e6561723f"></span><dl class="simple" id="index-8">
<dt><span class="spadfun">linear?</span>: P -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">linear?(p)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff <code class="docutils literal notranslate"><span class="pre">p</span></code> does not lie in the base ring <code class="docutils literal notranslate"><span class="pre">R</span></code> and has main degree <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-6c696e656172506f6c796e6f6d69616c73"></span><dl class="simple" id="index-9">
<dt><span class="spadfun">linearPolynomials</span>: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P -&gt; Record(goodPols: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, badPols: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">linearPolynomials(lp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">lps,</span> <span class="pre">nlps</span></code> where <code class="docutils literal notranslate"><span class="pre">lps</span></code> is a list of the linear polynomials in <code class="docutils literal notranslate"><span class="pre">lp</span></code>, and <code class="docutils literal notranslate"><span class="pre">nlps</span></code> are the other ones.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-706f737369626c794e6577566172696574793f"></span><dl class="simple" id="index-10">
<dt><span class="spadfun">possiblyNewVariety?</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P) -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">possiblyNewVariety?(newlp,</span> <span class="pre">llp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff for every <code class="docutils literal notranslate"><span class="pre">lp</span></code> in <code class="docutils literal notranslate"><span class="pre">llp</span></code> certainlySubVariety?(<code class="docutils literal notranslate"><span class="pre">newlp</span></code>, <code class="docutils literal notranslate"><span class="pre">lp</span></code>) does not hold.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-70726f6261626c795a65726f44696d3f"></span><dl class="simple" id="index-11">
<dt><span class="spadfun">probablyZeroDim?</span>: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">probablyZeroDim?(lp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff the number of polynomials in <code class="docutils literal notranslate"><span class="pre">lp</span></code> is not smaller than the number of variables occurring in these polynomials.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-71756173694d6f6e6963506f6c796e6f6d69616c73"></span><dl class="simple" id="index-12">
<dt><span class="spadfun">quasiMonicPolynomials</span>: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P -&gt; Record(goodPols: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, badPols: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">quasiMonicPolynomials(lp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">qmps,</span> <span class="pre">nqmps</span></code> where <code class="docutils literal notranslate"><span class="pre">qmps</span></code> is a list of the quasi-monic polynomials in <code class="docutils literal notranslate"><span class="pre">lp</span></code> and <code class="docutils literal notranslate"><span class="pre">nqmps</span></code> are the other ones.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-72656d6f76654972726564756369626c65526564756e64616e74466163746f7273"></span><dl class="simple" id="index-13">
<dt><span class="spadfun">removeIrreducibleRedundantFactors</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P if R has <a class="reference internal" href="PolynomialFactorizationExplicit.html#l506f6c796e6f6d69616c466163746f72697a6174696f6e4578706c69636974"><span class="std std-ref">PolynomialFactorizationExplicit</span></a> and R has <a class="reference internal" href="CharacteristicZero.html#l43686172616374657269737469635a65726f"><span class="std std-ref">CharacteristicZero</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">removeIrreducibleRedundantFactors(lp,</span> <span class="pre">lq)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">irreducibleFactors(concat(lp,</span> <span class="pre">lq))</span></code> assuming that <code class="docutils literal notranslate"><span class="pre">irreducibleFactors(lp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">lp</span></code> up to replacing some polynomial <code class="docutils literal notranslate"><span class="pre">pj</span></code> in <code class="docutils literal notranslate"><span class="pre">lp</span></code> by some polynomial <code class="docutils literal notranslate"><span class="pre">qj</span></code> associated to <code class="docutils literal notranslate"><span class="pre">pj</span></code>.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-72656d6f7665526564756e64616e74466163746f7273"></span><dl class="simple" id="index-14">
<dt><span class="spadfun">removeRedundantFactors</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">removeRedundantFactors(lp,</span> <span class="pre">lq)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">removeRedundantFactors(concat(lp,</span> <span class="pre">lq))</span></code> assuming that <code class="docutils literal notranslate"><span class="pre">removeRedundantFactors(lp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">lp</span></code> up to replacing some polynomial <code class="docutils literal notranslate"><span class="pre">pj</span></code> in <code class="docutils literal notranslate"><span class="pre">lp</span></code> by some polynomial <code class="docutils literal notranslate"><span class="pre">qj</span></code> associated to <code class="docutils literal notranslate"><span class="pre">pj</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-15">
<dt><span class="spadfun">removeRedundantFactors</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">removeRedundantFactors(lp,</span> <span class="pre">lq,</span> <span class="pre">remOp)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">concat(remOp(removeRoughlyRedundantFactorsInPols(lp,</span> <span class="pre">lq)),</span> <span class="pre">lq)</span></code> assuming that <code class="docutils literal notranslate"><span class="pre">remOp(lq)</span></code> returns <code class="docutils literal notranslate"><span class="pre">lq</span></code> up to similarity.</p>
</dd>
</dl>
<dl class="simple" id="index-16">
<dt><span class="spadfun">removeRedundantFactors</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, P) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">removeRedundantFactors(lp,</span> <span class="pre">q)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">removeRedundantFactors(cons(q,</span> <span class="pre">lp))</span></code> assuming that <code class="docutils literal notranslate"><span class="pre">removeRedundantFactors(lp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">lp</span></code> up to replacing some polynomial <code class="docutils literal notranslate"><span class="pre">pj</span></code> in <code class="docutils literal notranslate"><span class="pre">lp</span></code> by some some polynomial <code class="docutils literal notranslate"><span class="pre">qj</span></code> associated to <code class="docutils literal notranslate"><span class="pre">pj</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-17">
<dt><span class="spadfun">removeRedundantFactors</span>: (P, P) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">removeRedundantFactors(p,</span> <span class="pre">q)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">removeRedundantFactors([p,</span> <span class="pre">q])</span></code></p>
</dd>
</dl>
<dl class="simple" id="index-18">
<dt><span class="spadfun">removeRedundantFactors</span>: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">removeRedundantFactors(lp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">lq</span></code> such that if <code class="docutils literal notranslate"><span class="pre">lp</span> <span class="pre">=</span> <span class="pre">[p1,</span> <span class="pre">...,</span> <span class="pre">pn]</span></code> and <code class="docutils literal notranslate"><span class="pre">lq</span> <span class="pre">=</span> <span class="pre">[q1,</span> <span class="pre">...,</span> <span class="pre">qm]</span></code> then the product <code class="docutils literal notranslate"><span class="pre">p1*p2*...*pn</span></code> vanishes iff the product <code class="docutils literal notranslate"><span class="pre">q1*q2*...*qm</span></code> vanishes, and the product of degrees of the <code class="docutils literal notranslate"><span class="pre">qi</span></code> is not greater than the one of the <code class="docutils literal notranslate"><span class="pre">pj</span></code>, and no polynomial in <code class="docutils literal notranslate"><span class="pre">lq</span></code> divides another polynomial in <code class="docutils literal notranslate"><span class="pre">lq</span></code>. In particular, polynomials lying in the base ring <code class="docutils literal notranslate"><span class="pre">R</span></code> are removed. Moreover, <code class="docutils literal notranslate"><span class="pre">lq</span></code> is sorted with respect to <code class="docutils literal notranslate"><span class="pre">infRittWu?</span></code>. Furthermore, if <code class="docutils literal notranslate"><span class="pre">R</span></code> is <code class="docutils literal notranslate"><span class="pre">gcd</span></code>-domain, the polynomials in <code class="docutils literal notranslate"><span class="pre">lq</span></code> are pairwise without common non trivial factor.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-72656d6f7665526564756e64616e74466163746f7273496e436f6e74656e7473"></span><dl class="simple" id="index-19">
<dt><span class="spadfun">removeRedundantFactorsInContents</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P if R has <a class="reference internal" href="GcdDomain.html#l476364446f6d61696e"><span class="std std-ref">GcdDomain</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">removeRedundantFactorsInContents(lp,</span> <span class="pre">lf)</span></code> returns <code class="docutils literal notranslate"><span class="pre">newlp</span></code> where <code class="docutils literal notranslate"><span class="pre">newlp</span></code> is obtained from <code class="docutils literal notranslate"><span class="pre">lp</span></code> by removing in the content of every polynomial of <code class="docutils literal notranslate"><span class="pre">lp</span></code> any non trivial factor of any polynomial <code class="docutils literal notranslate"><span class="pre">f</span></code> in <code class="docutils literal notranslate"><span class="pre">lf</span></code>. Moreover, squares over <code class="docutils literal notranslate"><span class="pre">R</span></code> are first removed in the content of every polynomial of <code class="docutils literal notranslate"><span class="pre">lp</span></code>.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-72656d6f7665526564756e64616e74466163746f7273496e506f6c73"></span><dl class="simple" id="index-20">
<dt><span class="spadfun">removeRedundantFactorsInPols</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P if R has <a class="reference internal" href="GcdDomain.html#l476364446f6d61696e"><span class="std std-ref">GcdDomain</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">removeRedundantFactorsInPols(lp,</span> <span class="pre">lf)</span></code> returns <code class="docutils literal notranslate"><span class="pre">newlp</span></code> where <code class="docutils literal notranslate"><span class="pre">newlp</span></code> is obtained from <code class="docutils literal notranslate"><span class="pre">lp</span></code> by removing in every polynomial <code class="docutils literal notranslate"><span class="pre">p</span></code> of <code class="docutils literal notranslate"><span class="pre">lp</span></code> any non trivial factor of any polynomial <code class="docutils literal notranslate"><span class="pre">f</span></code> in <code class="docutils literal notranslate"><span class="pre">lf</span></code>. Moreover, squares over <code class="docutils literal notranslate"><span class="pre">R</span></code> are first removed in every polynomial <code class="docutils literal notranslate"><span class="pre">lp</span></code>.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-72656d6f7665526f7567686c79526564756e64616e74466163746f7273496e436f6e74656e7473"></span><dl class="simple" id="index-21">
<dt><span class="spadfun">removeRoughlyRedundantFactorsInContents</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P if R has <a class="reference internal" href="GcdDomain.html#l476364446f6d61696e"><span class="std std-ref">GcdDomain</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">removeRoughlyRedundantFactorsInContents(lp,</span> <span class="pre">lf)</span></code> returns <code class="docutils literal notranslate"><span class="pre">newlp</span></code>where <code class="docutils literal notranslate"><span class="pre">newlp</span></code> is obtained from <code class="docutils literal notranslate"><span class="pre">lp</span></code> by removing in the content of every polynomial of <code class="docutils literal notranslate"><span class="pre">lp</span></code> any occurrence of a polynomial <code class="docutils literal notranslate"><span class="pre">f</span></code> in <code class="docutils literal notranslate"><span class="pre">lf</span></code>. Moreover, squares over <code class="docutils literal notranslate"><span class="pre">R</span></code> are first removed in the content of every polynomial of <code class="docutils literal notranslate"><span class="pre">lp</span></code>.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-72656d6f7665526f7567686c79526564756e64616e74466163746f7273496e506f6c"></span><dl class="simple" id="index-22">
<dt><span class="spadfun">removeRoughlyRedundantFactorsInPol</span>: (P, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P) -&gt; P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">removeRoughlyRedundantFactorsInPol(p,</span> <span class="pre">lf)</span></code> returns the same as removeRoughlyRedundantFactorsInPols([<code class="docutils literal notranslate"><span class="pre">p</span></code>], <code class="docutils literal notranslate"><span class="pre">lf</span></code>, <code class="docutils literal notranslate"><span class="pre">true</span></code>)</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-72656d6f7665526f7567686c79526564756e64616e74466163746f7273496e506f6c73"></span><dl class="simple" id="index-23">
<dt><span class="spadfun">removeRoughlyRedundantFactorsInPols</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">removeRoughlyRedundantFactorsInPols(lp,</span> <span class="pre">lf)</span></code> returns <code class="docutils literal notranslate"><span class="pre">newlp</span></code>where <code class="docutils literal notranslate"><span class="pre">newlp</span></code> is obtained from <code class="docutils literal notranslate"><span class="pre">lp</span></code> by removing in every polynomial <code class="docutils literal notranslate"><span class="pre">p</span></code> of <code class="docutils literal notranslate"><span class="pre">lp</span></code> any occurrence of a polynomial <code class="docutils literal notranslate"><span class="pre">f</span></code> in <code class="docutils literal notranslate"><span class="pre">lf</span></code>. This may involve a lot of exact-quotients computations.</p>
</dd>
</dl>
<dl class="simple" id="index-24">
<dt><span class="spadfun">removeRoughlyRedundantFactorsInPols</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">removeRoughlyRedundantFactorsInPols(lp,</span> <span class="pre">lf,</span> <span class="pre">opt)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">removeRoughlyRedundantFactorsInPols(lp,</span> <span class="pre">lf)</span></code> if <code class="docutils literal notranslate"><span class="pre">opt</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code> and if the previous operation does not return any non null and constant polynomial, else return <code class="docutils literal notranslate"><span class="pre">[1]</span></code>.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-72656d6f766553717561726573496643616e"></span><dl class="simple" id="index-25">
<dt><span class="spadfun">removeSquaresIfCan</span>: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">removeSquaresIfCan(lp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">removeDuplicates</span> <span class="pre">[squareFreePart(p)\$P</span> <span class="pre">for</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">lp]</span></code> if <code class="docutils literal notranslate"><span class="pre">R</span></code> is <code class="docutils literal notranslate"><span class="pre">gcd</span></code>-domain else returns <code class="docutils literal notranslate"><span class="pre">lp</span></code>.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-72657772697465496465616c5769746851756173694d6f6e696347656e657261746f7273"></span><dl class="simple" id="index-26">
<dt><span class="spadfun">rewriteIdealWithQuasiMonicGenerators</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, (P, P) -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a>, (P, P) -&gt; P) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">rewriteIdealWithQuasiMonicGenerators(lp,</span> <span class="pre">redOp?,</span> <span class="pre">redOp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">lq</span></code> where <code class="docutils literal notranslate"><span class="pre">lq</span></code> and <code class="docutils literal notranslate"><span class="pre">lp</span></code> generate the same ideal in <code class="docutils literal notranslate"><span class="pre">R^(-1)</span> <span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">lq</span></code> has rank not higher than the one of <code class="docutils literal notranslate"><span class="pre">lp</span></code>. Moreover, <code class="docutils literal notranslate"><span class="pre">lq</span></code> is computed by reducing <code class="docutils literal notranslate"><span class="pre">lp</span></code> with respect to some basic set of the ideal generated by the quasi-monic polynomials in <code class="docutils literal notranslate"><span class="pre">lp</span></code>.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-7265777269746553657442795265647563696e6757697468506172746963756c617247656e657261746f7273"></span><dl class="simple" id="index-27">
<dt><span class="spadfun">rewriteSetByReducingWithParticularGenerators</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, P -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a>, (P, P) -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a>, (P, P) -&gt; P) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">rewriteSetByReducingWithParticularGenerators(lp,</span> <span class="pre">pred?,</span> <span class="pre">redOp?,</span> <span class="pre">redOp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">lq</span></code> where <code class="docutils literal notranslate"><span class="pre">lq</span></code> is computed by the following algorithm. Chose a basic set with respect to the reduction-test <code class="docutils literal notranslate"><span class="pre">redOp?</span></code> among the polynomials satisfying property <code class="docutils literal notranslate"><span class="pre">pred?</span></code>, if it is empty then leave, else reduce the other polynomials by this basic set with respect to the reduction-operation <code class="docutils literal notranslate"><span class="pre">redOp</span></code>. Repeat while another basic set with smaller rank can be computed. See code. If <code class="docutils literal notranslate"><span class="pre">pred?</span></code> is <code class="docutils literal notranslate"><span class="pre">quasiMonic?</span></code> the ideal is unchanged.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-726f7567684261736963536574"></span><dl class="simple" id="index-28">
<dt><span class="spadfun">roughBasicSet</span>: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P -&gt; Union(Record(bas: <a class="reference internal" href="GeneralTriangularSet.html#l47656e6572616c547269616e67756c6172536574"><span class="std std-ref">GeneralTriangularSet</span></a>(R, E, V, P), top: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P), failed)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">roughBasicSet(lp)</span></code> returns the smallest (with Ritt-Wu ordering) triangular set contained in <code class="docutils literal notranslate"><span class="pre">lp</span></code>.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-73656c656374416e64506f6c796e6f6d69616c73"></span><dl class="simple" id="index-29">
<dt><span class="spadfun">selectAndPolynomials</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a>(P -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a>), <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P) -&gt; Record(goodPols: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, badPols: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">selectAndPolynomials(lpred?,</span> <span class="pre">ps)</span></code> returns <code class="docutils literal notranslate"><span class="pre">gps,</span> <span class="pre">bps</span></code> where <code class="docutils literal notranslate"><span class="pre">gps</span></code> is a list of the polynomial <code class="docutils literal notranslate"><span class="pre">p</span></code> in <code class="docutils literal notranslate"><span class="pre">ps</span></code> such that <code class="docutils literal notranslate"><span class="pre">pred?(p)</span></code> holds for every <code class="docutils literal notranslate"><span class="pre">pred?</span></code> in <code class="docutils literal notranslate"><span class="pre">lpred?</span></code> and <code class="docutils literal notranslate"><span class="pre">bps</span></code> are the other ones.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-73656c6563744f72506f6c796e6f6d69616c73"></span><dl class="simple" id="index-30">
<dt><span class="spadfun">selectOrPolynomials</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a>(P -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a>), <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P) -&gt; Record(goodPols: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, badPols: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">selectOrPolynomials(lpred?,</span> <span class="pre">ps)</span></code> returns <code class="docutils literal notranslate"><span class="pre">gps,</span> <span class="pre">bps</span></code> where <code class="docutils literal notranslate"><span class="pre">gps</span></code> is a list of the polynomial <code class="docutils literal notranslate"><span class="pre">p</span></code> in <code class="docutils literal notranslate"><span class="pre">ps</span></code> such that <code class="docutils literal notranslate"><span class="pre">pred?(p)</span></code> holds for some <code class="docutils literal notranslate"><span class="pre">pred?</span></code> in <code class="docutils literal notranslate"><span class="pre">lpred?</span></code> and <code class="docutils literal notranslate"><span class="pre">bps</span></code> are the other ones.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-73656c656374506f6c796e6f6d69616c73"></span><dl class="simple" id="index-31">
<dt><span class="spadfun">selectPolynomials</span>: (P -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a>, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P) -&gt; Record(goodPols: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, badPols: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">selectPolynomials(pred?,</span> <span class="pre">ps)</span></code> returns <code class="docutils literal notranslate"><span class="pre">gps,</span> <span class="pre">bps</span></code> where <code class="docutils literal notranslate"><span class="pre">gps</span></code> is a list of the polynomial <code class="docutils literal notranslate"><span class="pre">p</span></code> in <code class="docutils literal notranslate"><span class="pre">ps</span></code> such that <code class="docutils literal notranslate"><span class="pre">pred?(p)</span></code> holds and <code class="docutils literal notranslate"><span class="pre">bps</span></code> are the other ones.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-73717561726546726565466163746f7273"></span><dl class="simple" id="index-32">
<dt><span class="spadfun">squareFreeFactors</span>: P -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P if R has <a class="reference internal" href="GcdDomain.html#l476364446f6d61696e"><span class="std std-ref">GcdDomain</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">squareFreeFactors(p)</span></code> returns the square-free factors of <code class="docutils literal notranslate"><span class="pre">p</span></code> over <code class="docutils literal notranslate"><span class="pre">R</span></code></p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-756e69766172696174653f"></span><dl class="simple" id="index-33">
<dt><span class="spadfun">univariate?</span>: P -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">univariate?(p)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff <code class="docutils literal notranslate"><span class="pre">p</span></code> involves one and only one variable.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-756e6976617269617465506f6c796e6f6d69616c73"></span><dl class="simple" id="index-34">
<dt><span class="spadfun">univariatePolynomials</span>: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P -&gt; Record(goodPols: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, badPols: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">univariatePolynomials(lp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">ups,</span> <span class="pre">nups</span></code> where <code class="docutils literal notranslate"><span class="pre">ups</span></code> is a list of the univariate polynomials, and <code class="docutils literal notranslate"><span class="pre">nups</span></code> are the other ones.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-756e6976617269617465506f6c796e6f6d69616c7347636473"></span><dl class="simple" id="index-35">
<dt><span class="spadfun">univariatePolynomialsGcds</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P, <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P if R has <a class="reference internal" href="GcdDomain.html#l476364446f6d61696e"><span class="std std-ref">GcdDomain</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">univariatePolynomialsGcds(lp,</span> <span class="pre">opt)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">univariatePolynomialsGcds(lp)</span></code> if <code class="docutils literal notranslate"><span class="pre">opt</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code> and if the previous operation does not return any non null and constant polynomial, else return <code class="docutils literal notranslate"><span class="pre">[1]</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-36">
<dt><span class="spadfun">univariatePolynomialsGcds</span>: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P if R has <a class="reference internal" href="GcdDomain.html#l476364446f6d61696e"><span class="std std-ref">GcdDomain</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">univariatePolynomialsGcds(lp)</span></code> returns <code class="docutils literal notranslate"><span class="pre">lg</span></code> where <code class="docutils literal notranslate"><span class="pre">lg</span></code> is a list of the gcds of every pair in <code class="docutils literal notranslate"><span class="pre">lp</span></code> of univariate polynomials in the same main variable.</p>
</dd>
</dl>
<span id="l506f6c796e6f6d69616c5365745574696c69746965735061636b616765-756e70726f74656374656452656d6f7665526564756e64616e74466163746f7273"></span><dl class="simple" id="index-37">
<dt><span class="spadfun">unprotectedRemoveRedundantFactors</span>: (P, P) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">unprotectedRemoveRedundantFactors(p,</span> <span class="pre">q)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">removeRedundantFactors(p,</span> <span class="pre">q)</span></code> but does assume that neither <code class="docutils literal notranslate"><span class="pre">p</span></code> nor <code class="docutils literal notranslate"><span class="pre">q</span></code> lie in the base ring <code class="docutils literal notranslate"><span class="pre">R</span></code> and assumes that <code class="docutils literal notranslate"><span class="pre">infRittWu?(p,</span> <span class="pre">q)</span></code> holds. Moreover, if <code class="docutils literal notranslate"><span class="pre">R</span></code> is <code class="docutils literal notranslate"><span class="pre">gcd</span></code>-domain, then <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> are assumed to be square free.</p>
</dd>
</dl>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">FriCAS API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../download.html">Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="../help.html">Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citation.html">Citation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">History</a></li>
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="PolynomialSolveByFormulas.html" title="PolynomialSolveByFormulas(UP, F, RR)"
             >next</a> |</li>
        <li class="right" >
          <a href="PolynomialRoots.html" title="PolynomialRoots(E, V, R, P, F)"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">FriCAS</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >FriCAS API</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="Packages.html" >Packages</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">PolynomialSetUtilitiesPackage(R, E, V, P)</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2007-2025, FriCAS Team.
    </div>
  </body>
</html>