<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ComplexRootFindingPackage(R, UP) &mdash; FriCAS 1.2.7 API</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.2.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="FriCAS 1.2.7 API" href="index.html" />
    <link rel="up" title="Packages" href="Packages.html" />
    <link rel="next" title="ComplexRootPackage(UP, Par)" href="ComplexRootPackage.html" />
    <link rel="prev" title="ComplexPatternMatch(R, S, CS)" href="ComplexPatternMatch.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="ComplexRootPackage.html" title="ComplexRootPackage(UP, Par)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="ComplexPatternMatch.html" title="ComplexPatternMatch(R, S, CS)"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">FriCAS 1.2.7 API</a> &raquo;</li>
          <li><a href="Packages.html" accesskey="U">Packages</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="complexrootfindingpackage-r-up">
<span id="l-complex-root-finding-package"></span><span id="index-0"></span><h1>ComplexRootFindingPackage(R, UP)<a class="headerlink" href="#complexrootfindingpackage-r-up" title="Permalink to this headline">Â¶</a></h1>
<p><a class="reference external" href="https://github.com/hemmecke/fricas/blob/master-hemmecke/src/algebra//crfp.spad#L1">crfp.spad line 1</a></p>
<ul class="simple">
<li>R: Join(<a class="reference internal" href="Field.html#l-field"><em>Field</em></a>, <a class="reference internal" href="OrderedRing.html#l-ordered-ring"><em>OrderedRing</em></a>)</li>
<li>UP: <a class="reference internal" href="UnivariatePolynomialCategory.html#l-univariate-polynomial-category"><em>UnivariatePolynomialCategory</em></a> <a class="reference internal" href="Complex.html#l-complex"><em>Complex</em></a> R</li>
</ul>
<p><a class="reference internal" href="#l-complex-root-finding-package"><em>ComplexRootFindingPackage</em></a> provides functions to find all roots of a polynomial <tt class="docutils literal"><span class="pre">p</span></tt> over the complex number by using Plesken<tt class="docutils literal"><span class="pre">'s</span></tt> idea to calculate in the polynomial ring modulo <tt class="docutils literal"><span class="pre">f</span></tt> and employing the Chinese Remainder Theorem. In this first version, the precision (see <em class="xref std std-ref">digits</em>) is not increased when this is necessary to avoid rounding errors. Hence it is the user<tt class="docutils literal"><span class="pre">'s</span></tt> responsibility to increase the precision if necessary. Note also, if this package is called with e.g. <em class="xref std std-ref">Fraction Integer</em>, the precise calculations could require a lot of time. Also note that evaluating the zeros is not necessarily a good check whether the result is correct: already evaluation can cause rounding errors.</p>
<span class="target" id="l-complex-root-finding-package-complex-zeros"></span><dl class="docutils" id="index-1">
<dt><span class="spadfun">complexZeros</span>: (UP, R) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Complex.html#l-complex"><em>Complex</em></a> R</dt>
<dd><tt class="docutils literal"><span class="pre">complexZeros(p,</span> <span class="pre">eps)</span></tt> tries to determine all complex zeros of the polynomial <tt class="docutils literal"><span class="pre">p</span></tt> with accuracy given by <em>eps</em>.</dd>
</dl>
<dl class="docutils" id="index-2">
<dt><span class="spadfun">complexZeros</span>: UP -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Complex.html#l-complex"><em>Complex</em></a> R</dt>
<dd><tt class="docutils literal"><span class="pre">complexZeros(p)</span></tt> tries to determine all complex zeros of the polynomial <tt class="docutils literal"><span class="pre">p</span></tt> with accuracy given by the package constant <em>globalEps</em> which you may change by <em>setErrorBound</em>.</dd>
</dl>
<span class="target" id="l-complex-root-finding-package-divisor-cascade"></span><dl class="docutils" id="index-3">
<dt><span class="spadfun">divisorCascade</span>: (UP, UP) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> Record(factors: <a class="reference internal" href="List.html#l-list"><em>List</em></a> UP, error: R)</dt>
<dd><tt class="docutils literal"><span class="pre">divisorCascade(p,</span> <span class="pre">tp)</span></tt> assumes that degree of polynomial <em>tp</em> is smaller than degree of polynomial <tt class="docutils literal"><span class="pre">p</span></tt>, both monic. A sequence of divisions is calculated using the remainder, made monic, as divisor for the the next division. The result contains also the error of the factorizations, i.e. the norm of the remainder polynomial.</dd>
</dl>
<dl class="docutils" id="index-4">
<dt><span class="spadfun">divisorCascade</span>: (UP, UP, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> Record(factors: <a class="reference internal" href="List.html#l-list"><em>List</em></a> UP, error: R)</dt>
<dd><tt class="docutils literal"><span class="pre">divisorCascade(p,</span> <span class="pre">tp)</span></tt> assumes that degree of polynomial <em>tp</em> is smaller than degree of polynomial <tt class="docutils literal"><span class="pre">p</span></tt>, both monic. A sequence of divisions are calculated using the remainder, made monic, as divisor for the the next division. The result contains also the error of the factorizations, i.e. the norm of the remainder polynomial. If <em>info</em> is <em>true</em>, then information messages are issued.</dd>
</dl>
<span class="target" id="l-complex-root-finding-package-factor"></span><dl class="docutils" id="index-5">
<dt><span class="spadfun">factor</span>: (UP, R) -&gt; <a class="reference internal" href="Factored.html#l-factored"><em>Factored</em></a> UP</dt>
<dd><tt class="docutils literal"><span class="pre">factor(p,</span> <span class="pre">eps)</span></tt> tries to factor <tt class="docutils literal"><span class="pre">p</span></tt> into linear factors with error atmost <em>eps</em>. An overall error bound <em>eps0</em> is determined and iterated tree-like calls to <em>pleskenSplit</em> are used to get the factorization.</dd>
</dl>
<dl class="docutils" id="index-6">
<dt><span class="spadfun">factor</span>: (UP, R, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>) -&gt; <a class="reference internal" href="Factored.html#l-factored"><em>Factored</em></a> UP</dt>
<dd><tt class="docutils literal"><span class="pre">factor(p,</span> <span class="pre">eps,</span> <span class="pre">info)</span></tt> tries to factor <tt class="docutils literal"><span class="pre">p</span></tt> into linear factors with error atmost <em>eps</em>. An overall error bound <em>eps0</em> is determined and iterated tree-like calls to <em>pleskenSplit</em> are used to get the factorization. If <em>info</em> is <em>true</em>, then information messages are given.</dd>
</dl>
<dl class="docutils" id="index-7">
<dt><span class="spadfun">factor</span>: UP -&gt; <a class="reference internal" href="Factored.html#l-factored"><em>Factored</em></a> UP</dt>
<dd><tt class="docutils literal"><span class="pre">factor(p)</span></tt> tries to factor <tt class="docutils literal"><span class="pre">p</span></tt> into linear factors with error atmost <em>globalEps</em>, the internal error bound, which can be set by <em>setErrorBound</em>. An overall error bound <em>eps0</em> is determined and iterated tree-like calls to <em>pleskenSplit</em> are used to get the factorization.</dd>
</dl>
<span class="target" id="l-complex-root-finding-package-graeffe"></span><dl class="docutils" id="index-8">
<dt><span class="spadfun">graeffe</span>: UP -&gt; UP</dt>
<dd><tt class="docutils literal"><span class="pre">graeffe</span> <span class="pre">p</span></tt> determines <tt class="docutils literal"><span class="pre">q</span></tt> such that <tt class="docutils literal"><span class="pre">q(-z^2)</span> <span class="pre">=</span> <span class="pre">p(z)*p(-z)</span></tt>. Note that the roots of <tt class="docutils literal"><span class="pre">q</span></tt> are the squares of the roots of <tt class="docutils literal"><span class="pre">p</span></tt>.</dd>
</dl>
<span class="target" id="l-complex-root-finding-package-norm"></span><dl class="docutils" id="index-9">
<dt><span class="spadfun">norm</span>: UP -&gt; R</dt>
<dd><tt class="docutils literal"><span class="pre">norm(p)</span></tt> determines sum of absolute values of coefficients Note: this function depends on <em class="xref std std-ref">abs</em>.</dd>
</dl>
<span class="target" id="l-complex-root-finding-package-plesken-split"></span><dl class="docutils" id="index-10">
<dt><span class="spadfun">pleskenSplit</span>: (UP, R) -&gt; <a class="reference internal" href="Factored.html#l-factored"><em>Factored</em></a> UP</dt>
<dd><tt class="docutils literal"><span class="pre">pleskenSplit(poly,</span> <span class="pre">eps)</span></tt> determines a start polynomial <em>start</em>\ by using &#8220;startPolynomial then it increases the exponent <tt class="docutils literal"><span class="pre">n</span></tt> of <em>start ^ n mod poly</em> to get an approximate factor of <em>poly</em>, in general of degree &#8220;degree <tt class="docutils literal"><span class="pre">poly</span></tt> <tt class="docutils literal"><span class="pre">-1&quot;</span></tt>. Then a divisor cascade is calculated and the best splitting is chosen, as soon as the error is small enough.</dd>
</dl>
<dl class="docutils" id="index-11">
<dt><span class="spadfun">pleskenSplit</span>: (UP, R, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>) -&gt; <a class="reference internal" href="Factored.html#l-factored"><em>Factored</em></a> UP</dt>
<dd><tt class="docutils literal"><span class="pre">pleskenSplit(poly,</span> <span class="pre">eps,</span> <span class="pre">info)</span></tt> determines a start polynomial <em>start</em> by using &#8220;startPolynomial then it increases the exponent <tt class="docutils literal"><span class="pre">n</span></tt> of <em>start ^ n mod poly</em> to get an approximate factor of <em>poly</em>, in general of degree &#8220;degree <tt class="docutils literal"><span class="pre">poly</span></tt> <tt class="docutils literal"><span class="pre">-1&quot;</span></tt>. Then a divisor cascade is calculated and the best splitting is chosen, as soon as the error is small enough. If <em>info</em> is <em>true</em>, then information messages are issued.</dd>
</dl>
<span class="target" id="l-complex-root-finding-package-reciprocal-polynomial"></span><dl class="docutils" id="index-12">
<dt><span class="spadfun">reciprocalPolynomial</span>: UP -&gt; UP</dt>
<dd><tt class="docutils literal"><span class="pre">reciprocalPolynomial(p)</span></tt> calulates a polynomial which has exactly the inverses of the non-zero roots of <tt class="docutils literal"><span class="pre">p</span></tt> as roots, and the same number of 0-roots.</dd>
</dl>
<span class="target" id="l-complex-root-finding-package-root-radius"></span><dl class="docutils" id="index-13">
<dt><span class="spadfun">rootRadius</span>: (UP, R) -&gt; R</dt>
<dd><tt class="docutils literal"><span class="pre">rootRadius(p,</span> <span class="pre">errQuot)</span></tt> calculates the root radius of <tt class="docutils literal"><span class="pre">p</span></tt> with a maximal error quotient of <em>errQuot</em>.</dd>
</dl>
<dl class="docutils" id="index-14">
<dt><span class="spadfun">rootRadius</span>: UP -&gt; R</dt>
<dd><tt class="docutils literal"><span class="pre">rootRadius(p)</span></tt> calculates the root radius of <tt class="docutils literal"><span class="pre">p</span></tt> with a maximal error quotient of <em>1+globalEps</em>, where <em>globalEps</em> is the internal error bound, which can be set by <em>setErrorBound</em>.</dd>
</dl>
<span class="target" id="l-complex-root-finding-package-schwerpunkt"></span><dl class="docutils" id="index-15">
<dt><span class="spadfun">schwerpunkt</span>: UP -&gt; <a class="reference internal" href="Complex.html#l-complex"><em>Complex</em></a> R</dt>
<dd><tt class="docutils literal"><span class="pre">schwerpunkt(p)</span></tt> determines the &#8216;Schwerpunkt&#8217; of the roots of the polynomial <tt class="docutils literal"><span class="pre">p</span></tt> of degree <tt class="docutils literal"><span class="pre">n</span></tt>, i.e. the center of gravity, which is <a href="#id1"><span class="problematic" id="id2">*</span></a>coefficient of <tt class="docutils literal"><span class="pre">x^(n-1)</span></tt><a href="#id3"><span class="problematic" id="id4">*</span></a> divided by <a href="#id5"><span class="problematic" id="id6">*</span></a>n times coefficient of <tt class="docutils literal"><span class="pre">x^n</span></tt><a href="#id7"><span class="problematic" id="id8">*</span></a>.</dd>
</dl>
<span class="target" id="l-complex-root-finding-package-set-error-bound"></span><dl class="docutils" id="index-16">
<dt><span class="spadfun">setErrorBound</span>: R -&gt; R</dt>
<dd><tt class="docutils literal"><span class="pre">setErrorBound(eps)</span></tt> changes the internal error bound, by default being <em>10 ^ (-3)</em> to <tt class="docutils literal"><span class="pre">eps</span></tt>, if <tt class="docutils literal"><span class="pre">R</span></tt> is a member in the category <em class="xref std std-ref">QuotientFieldCategory Integer</em>. The internal <em>globalDigits</em> is set to <em>ceiling(1/r)^2*10</em> being <em>10^7</em> by default.</dd>
</dl>
<span class="target" id="l-complex-root-finding-package-start-polynomial"></span><dl class="docutils" id="index-17">
<dt><span class="spadfun">startPolynomial</span>: UP -&gt; Record(start: UP, factors: <a class="reference internal" href="Factored.html#l-factored"><em>Factored</em></a> UP)</dt>
<dd><tt class="docutils literal"><span class="pre">startPolynomial(p)</span></tt> uses the ideas of Schoenhage<tt class="docutils literal"><span class="pre">'s</span></tt> variant of Graeffe<tt class="docutils literal"><span class="pre">'s</span></tt> method to construct circles which separate roots to get a good start polynomial, i.e. one whose image under the Chinese Remainder Isomorphism has both entries of norm smaller and greater or equal to 1. In case the roots are found during internal calculations. The corresponding factors are in <em>factors</em> which are otherwise 1.</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h3><a href="index.html">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Categories.html">Categories</a></li>
<li class="toctree-l1"><a class="reference internal" href="Domains.html">Domains</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Packages.html">Packages</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="ComplexRootPackage.html" title="ComplexRootPackage(UP, Par)"
             >next</a> |</li>
        <li class="right" >
          <a href="ComplexPatternMatch.html" title="ComplexPatternMatch(R, S, CS)"
             >previous</a> |</li>
        <li><a href="index.html">FriCAS 1.2.7 API</a> &raquo;</li>
          <li><a href="Packages.html" >Packages</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014-2015, FriCAS Team.
    </div>
  </body>
</html>