<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ZeroDimensionalSolvePackage(R, ls, ls2) &mdash; FriCAS 1.2.7 API</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.2.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="FriCAS 1.2.7 API" href="index.html" />
    <link rel="up" title="Packages" href="Packages.html" />
    <link rel="next" title="Commit History" href="history.html" />
    <link rel="prev" title="XExponentialPackage(R, VarSet, XPOLY)" href="XExponentialPackage.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="history.html" title="Commit History"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="XExponentialPackage.html" title="XExponentialPackage(R, VarSet, XPOLY)"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">FriCAS 1.2.7 API</a> &raquo;</li>
          <li><a href="Packages.html" accesskey="U">Packages</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="zerodimensionalsolvepackage-r-ls-ls2">
<span id="l-zero-dimensional-solve-package"></span><span id="index-0"></span><h1>ZeroDimensionalSolvePackage(R, ls, ls2)<a class="headerlink" href="#zerodimensionalsolvepackage-r-ls-ls2" title="Permalink to this headline">Â¶</a></h1>
<p><a class="reference external" href="https://github.com/hemmecke/fricas/blob/master-hemmecke/src/algebra//zerodim.spad#L655">zerodim.spad line 655</a></p>
<ul class="simple">
<li>R: Join(<a class="reference internal" href="OrderedRing.html#l-ordered-ring"><em>OrderedRing</em></a>, <a class="reference internal" href="EuclideanDomain.html#l-euclidean-domain"><em>EuclideanDomain</em></a>, <a class="reference internal" href="CharacteristicZero.html#l-characteristic-zero"><em>CharacteristicZero</em></a>, <a class="reference internal" href="RealConstant.html#l-real-constant"><em>RealConstant</em></a>)</li>
<li>ls: <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Symbol.html#l-symbol"><em>Symbol</em></a></li>
<li>ls2: <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Symbol.html#l-symbol"><em>Symbol</em></a></li>
</ul>
<p>A package for computing symbolically the complex and real roots of zero-dimensional algebraic systems over the integer or rational numbers. Complex roots are given by means of univariate representations of irreducible regular chains. Real roots are given by means of tuples of coordinates lying in the <a class="reference internal" href="RealClosure.html#l-real-closure"><em>RealClosure</em></a> of the coefficient ring. This constructor takes three arguments. The first one <tt class="docutils literal"><span class="pre">R</span></tt> is the coefficient ring. The second one <tt class="docutils literal"><span class="pre">ls</span></tt> is the list of variables involved in the systems to solve. The third one must be <tt class="docutils literal"><span class="pre">concat(ls,</span> <span class="pre">s)</span></tt> where <tt class="docutils literal"><span class="pre">s</span></tt> is an additional symbol used for the univariate representations. WARNING: The third argument is not checked. All operations are based on triangular decompositions. The default is to compute these decompositions directly from the input system by using the <a class="reference internal" href="RegularChain.html#l-regular-chain"><em>RegularChain</em></a> domain constructor. The lexTriangular algorithm can also be used for computing these decompositions (see the <a class="reference internal" href="LexTriangularPackage.html#l-lex-triangular-package"><em>LexTriangularPackage</em></a> package constructor). For that purpose, the operations <a class="reference internal" href="#l-zero-dimensional-solve-package-univariate-solve"><em>univariateSolve</em></a>, <a class="reference internal" href="#l-zero-dimensional-solve-package-real-solve"><em>realSolve</em></a> and <a class="reference internal" href="#l-zero-dimensional-solve-package-positive-solve"><em>positiveSolve</em></a> admit an optional argument.   Author: Marc Moreno Maza.</p>
<span class="target" id="l-zero-dimensional-solve-package-convert"></span><dl class="docutils" id="index-1">
<dt><span class="spadfun">convert</span>: <a class="reference internal" href="NewSparseMultivariatePolynomial.html#l-new-sparse-multivariate-polynomial"><em>NewSparseMultivariatePolynomial</em></a>(R, <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><em>OrderedVariableList</em></a> ls) -&gt; <a class="reference internal" href="NewSparseMultivariatePolynomial.html#l-new-sparse-multivariate-polynomial"><em>NewSparseMultivariatePolynomial</em></a>(R, <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><em>OrderedVariableList</em></a> ls2)</dt>
<dd><tt class="docutils literal"><span class="pre">convert(q)</span></tt> converts <tt class="docutils literal"><span class="pre">q</span></tt>.</dd>
</dl>
<dl class="docutils" id="index-2">
<dt><span class="spadfun">convert</span>: <a class="reference internal" href="NewSparseMultivariatePolynomial.html#l-new-sparse-multivariate-polynomial"><em>NewSparseMultivariatePolynomial</em></a>(R, <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><em>OrderedVariableList</em></a> ls2) -&gt; <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><em>RealClosure</em></a> <a class="reference internal" href="Fraction.html#l-fraction"><em>Fraction</em></a> R</dt>
<dd><tt class="docutils literal"><span class="pre">convert(q)</span></tt> converts <tt class="docutils literal"><span class="pre">q</span></tt>.</dd>
</dl>
<dl class="docutils" id="index-3">
<dt><span class="spadfun">convert</span>: <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R -&gt; <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><em>RealClosure</em></a> <a class="reference internal" href="Fraction.html#l-fraction"><em>Fraction</em></a> R</dt>
<dd><tt class="docutils literal"><span class="pre">convert(p)</span></tt> converts <tt class="docutils literal"><span class="pre">p</span></tt>.</dd>
</dl>
<dl class="docutils" id="index-4">
<dt><span class="spadfun">convert</span>: <a class="reference internal" href="SparseUnivariatePolynomial.html#l-sparse-univariate-polynomial"><em>SparseUnivariatePolynomial</em></a> R -&gt; <a class="reference internal" href="SparseUnivariatePolynomial.html#l-sparse-univariate-polynomial"><em>SparseUnivariatePolynomial</em></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><em>RealClosure</em></a> <a class="reference internal" href="Fraction.html#l-fraction"><em>Fraction</em></a> R</dt>
<dd><tt class="docutils literal"><span class="pre">convert(u)</span></tt> converts <tt class="docutils literal"><span class="pre">u</span></tt>.</dd>
</dl>
<dl class="docutils" id="index-5">
<dt><span class="spadfun">convert</span>: <a class="reference internal" href="SquareFreeRegularTriangularSet.html#l-square-free-regular-triangular-set"><em>SquareFreeRegularTriangularSet</em></a>(R, <a class="reference internal" href="IndexedExponents.html#l-indexed-exponents"><em>IndexedExponents</em></a> <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><em>OrderedVariableList</em></a> ls2, <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><em>OrderedVariableList</em></a> ls2, <a class="reference internal" href="NewSparseMultivariatePolynomial.html#l-new-sparse-multivariate-polynomial"><em>NewSparseMultivariatePolynomial</em></a>(R, <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><em>OrderedVariableList</em></a> ls2)) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="NewSparseMultivariatePolynomial.html#l-new-sparse-multivariate-polynomial"><em>NewSparseMultivariatePolynomial</em></a>(R, <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><em>OrderedVariableList</em></a> ls2)</dt>
<dd><tt class="docutils literal"><span class="pre">convert(st)</span></tt> returns the members of <tt class="docutils literal"><span class="pre">st</span></tt>.</dd>
</dl>
<span class="target" id="l-zero-dimensional-solve-package-positive-solve"></span><dl class="docutils" id="index-6">
<dt><span class="spadfun">positiveSolve</span>: (<a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><em>RealClosure</em></a> <a class="reference internal" href="Fraction.html#l-fraction"><em>Fraction</em></a> R</dt>
<dd><tt class="docutils literal"><span class="pre">positiveSolve(lp)</span></tt> returns the same as <tt class="docutils literal"><span class="pre">positiveSolve(lp,</span> <span class="pre">info?,</span> <span class="pre">false)</span></tt>.</dd>
</dl>
<dl class="docutils" id="index-7">
<dt><span class="spadfun">positiveSolve</span>: (<a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><em>RealClosure</em></a> <a class="reference internal" href="Fraction.html#l-fraction"><em>Fraction</em></a> R</dt>
<dd><tt class="docutils literal"><span class="pre">positiveSolve(lp,</span> <span class="pre">info?,</span> <span class="pre">lextri?)</span></tt> returns the set of the points in the variety associated with <tt class="docutils literal"><span class="pre">lp</span></tt> whose coordinates are (real) strictly positive. Moreover, if <tt class="docutils literal"><span class="pre">info?</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> then some information is displayed during decomposition into regular chains. If <tt class="docutils literal"><span class="pre">lextri?</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> then the lexTriangular algorithm is called from the <a class="reference internal" href="LexTriangularPackage.html#l-lex-triangular-package"><em>LexTriangularPackage</em></a> constructor (see <em class="xref std std-ref">zeroSetSplit &lt;l&#8211;lex-triangular-package_zero-set-split&gt;`(``lp`</em>, <tt class="docutils literal"><span class="pre">false</span></tt>)). Otherwise, the triangular decomposition is computed directly from the input system by using the <a class="reference internal" href="RegularChain.html#l-regular-chain-zero-set-split"><em>zeroSetSplit</em></a> from <a class="reference internal" href="RegularChain.html#l-regular-chain"><em>RegularChain</em></a>. WARNING: For each set of coordinates given by <tt class="docutils literal"><span class="pre">positiveSolve(lp,</span> <span class="pre">info?,</span> <span class="pre">lextri?)</span></tt> the ordering of the indeterminates is reversed <tt class="docutils literal"><span class="pre">w</span></tt>.<tt class="docutils literal"><span class="pre">r</span></tt>.<tt class="docutils literal"><span class="pre">t</span></tt>. <tt class="docutils literal"><span class="pre">ls</span></tt>.</dd>
</dl>
<dl class="docutils" id="index-8">
<dt><span class="spadfun">positiveSolve</span>: <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><em>RealClosure</em></a> <a class="reference internal" href="Fraction.html#l-fraction"><em>Fraction</em></a> R</dt>
<dd><tt class="docutils literal"><span class="pre">positiveSolve(lp)</span></tt> returns the same as <tt class="docutils literal"><span class="pre">positiveSolve(lp,</span> <span class="pre">false,</span> <span class="pre">false)</span></tt>.</dd>
</dl>
<dl class="docutils" id="index-9">
<dt><span class="spadfun">positiveSolve</span>: <a class="reference internal" href="RegularChain.html#l-regular-chain"><em>RegularChain</em></a>(R, ls) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><em>RealClosure</em></a> <a class="reference internal" href="Fraction.html#l-fraction"><em>Fraction</em></a> R</dt>
<dd><tt class="docutils literal"><span class="pre">positiveSolve(ts)</span></tt> returns the points of the regular set of <tt class="docutils literal"><span class="pre">ts</span></tt> with (real) strictly positive coordinates.</dd>
</dl>
<span class="target" id="l-zero-dimensional-solve-package-real-solve"></span><dl class="docutils" id="index-10">
<dt><span class="spadfun">realSolve</span>: (<a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><em>RealClosure</em></a> <a class="reference internal" href="Fraction.html#l-fraction"><em>Fraction</em></a> R</dt>
<dd><tt class="docutils literal"><span class="pre">realSolve(ts,</span> <span class="pre">info?)</span></tt> returns the same as <tt class="docutils literal"><span class="pre">realSolve(ts,</span> <span class="pre">info?,</span> <span class="pre">false,</span> <span class="pre">false)</span></tt>.</dd>
</dl>
<dl class="docutils" id="index-11">
<dt><span class="spadfun">realSolve</span>: (<a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><em>RealClosure</em></a> <a class="reference internal" href="Fraction.html#l-fraction"><em>Fraction</em></a> R</dt>
<dd><tt class="docutils literal"><span class="pre">realSolve(ts,</span> <span class="pre">info?,</span> <span class="pre">check?)</span></tt> returns the same as <tt class="docutils literal"><span class="pre">realSolve(ts,</span> <span class="pre">info?,</span> <span class="pre">check?,</span> <span class="pre">false)</span></tt>.</dd>
</dl>
<dl class="docutils" id="index-12">
<dt><span class="spadfun">realSolve</span>: (<a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><em>RealClosure</em></a> <a class="reference internal" href="Fraction.html#l-fraction"><em>Fraction</em></a> R</dt>
<dd><tt class="docutils literal"><span class="pre">realSolve(ts,</span> <span class="pre">info?,</span> <span class="pre">check?,</span> <span class="pre">lextri?)</span></tt> returns the set of the points in the variety associated with <tt class="docutils literal"><span class="pre">lp</span></tt> whose coordinates are all real. Moreover, if <tt class="docutils literal"><span class="pre">info?</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> then some information is displayed during decomposition into regular chains. If <tt class="docutils literal"><span class="pre">check?</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> then the result is checked. If <tt class="docutils literal"><span class="pre">lextri?</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> then the lexTriangular algorithm is called from the <a class="reference internal" href="LexTriangularPackage.html#l-lex-triangular-package"><em>LexTriangularPackage</em></a> constructor (see <em class="xref std std-ref">zeroSetSplit &lt;l&#8211;lex-triangular-package_zero-set-split&gt;`(``lp`</em>, <tt class="docutils literal"><span class="pre">false</span></tt>)). Otherwise, the triangular decomposition is computed directly from the input system by using the <a class="reference internal" href="RegularChain.html#l-regular-chain-zero-set-split"><em>zeroSetSplit</em></a> from <a class="reference internal" href="RegularChain.html#l-regular-chain"><em>RegularChain</em></a>. WARNING: For each set of coordinates given by <tt class="docutils literal"><span class="pre">realSolve(ts,</span> <span class="pre">info?,</span> <span class="pre">check?,</span> <span class="pre">lextri?)</span></tt> the ordering of the indeterminates is reversed <tt class="docutils literal"><span class="pre">w</span></tt>.<tt class="docutils literal"><span class="pre">r</span></tt>.<tt class="docutils literal"><span class="pre">t</span></tt>. <tt class="docutils literal"><span class="pre">ls</span></tt>.</dd>
</dl>
<dl class="docutils" id="index-13">
<dt><span class="spadfun">realSolve</span>: <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><em>RealClosure</em></a> <a class="reference internal" href="Fraction.html#l-fraction"><em>Fraction</em></a> R</dt>
<dd><tt class="docutils literal"><span class="pre">realSolve(lp)</span></tt> returns the same as <tt class="docutils literal"><span class="pre">realSolve(ts,</span> <span class="pre">false,</span> <span class="pre">false,</span> <span class="pre">false)</span></tt></dd>
</dl>
<dl class="docutils" id="index-14">
<dt><span class="spadfun">realSolve</span>: <a class="reference internal" href="RegularChain.html#l-regular-chain"><em>RegularChain</em></a>(R, ls) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><em>RealClosure</em></a> <a class="reference internal" href="Fraction.html#l-fraction"><em>Fraction</em></a> R</dt>
<dd><tt class="docutils literal"><span class="pre">realSolve(ts)</span></tt> returns the set of the points in the regular zero set of <tt class="docutils literal"><span class="pre">ts</span></tt> whose coordinates are all real. WARNING: For each set of coordinates given by <tt class="docutils literal"><span class="pre">realSolve(ts)</span></tt> the ordering of the indeterminates is reversed <tt class="docutils literal"><span class="pre">w</span></tt>.<tt class="docutils literal"><span class="pre">r</span></tt>.<tt class="docutils literal"><span class="pre">t</span></tt>. <tt class="docutils literal"><span class="pre">ls</span></tt>.</dd>
</dl>
<span class="target" id="l-zero-dimensional-solve-package-square-free"></span><dl class="docutils" id="index-15">
<dt><span class="spadfun">squareFree</span>: <a class="reference internal" href="RegularChain.html#l-regular-chain"><em>RegularChain</em></a>(R, ls) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="SquareFreeRegularTriangularSet.html#l-square-free-regular-triangular-set"><em>SquareFreeRegularTriangularSet</em></a>(R, <a class="reference internal" href="IndexedExponents.html#l-indexed-exponents"><em>IndexedExponents</em></a> <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><em>OrderedVariableList</em></a> ls2, <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><em>OrderedVariableList</em></a> ls2, <a class="reference internal" href="NewSparseMultivariatePolynomial.html#l-new-sparse-multivariate-polynomial"><em>NewSparseMultivariatePolynomial</em></a>(R, <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><em>OrderedVariableList</em></a> ls2))</dt>
<dd><tt class="docutils literal"><span class="pre">squareFree(ts)</span></tt> returns the square-free factorization of <tt class="docutils literal"><span class="pre">ts</span></tt>. Moreover, each factor is a Lazard triangular set and the decomposition is a Kalkbrener split of <tt class="docutils literal"><span class="pre">ts</span></tt>, which is enough here for the matter of solving zero-dimensional algebraic systems. WARNING: <tt class="docutils literal"><span class="pre">ts</span></tt> is not checked to be zero-dimensional.</dd>
</dl>
<span class="target" id="l-zero-dimensional-solve-package-triang-solve"></span><dl class="docutils" id="index-16">
<dt><span class="spadfun">triangSolve</span>: (<a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="RegularChain.html#l-regular-chain"><em>RegularChain</em></a>(R, ls)</dt>
<dd><tt class="docutils literal"><span class="pre">triangSolve(lp,</span> <span class="pre">info?)</span></tt> returns the same as <tt class="docutils literal"><span class="pre">triangSolve(lp,</span> <span class="pre">false)</span></tt></dd>
</dl>
<dl class="docutils" id="index-17">
<dt><span class="spadfun">triangSolve</span>: (<a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="RegularChain.html#l-regular-chain"><em>RegularChain</em></a>(R, ls)</dt>
<dd><tt class="docutils literal"><span class="pre">triangSolve(lp,</span> <span class="pre">info?,</span> <span class="pre">lextri?)</span></tt> decomposes the variety associated with <tt class="docutils literal"><span class="pre">lp</span></tt> into regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in in the output. Note that <tt class="docutils literal"><span class="pre">lp</span></tt> needs to generate a zero-dimensional ideal. If <tt class="docutils literal"><span class="pre">lp</span></tt> is not zero-dimensional then the result is only a decomposition of its zero-set in the sense of the closure (<tt class="docutils literal"><span class="pre">w</span></tt>.<tt class="docutils literal"><span class="pre">r</span></tt>.<tt class="docutils literal"><span class="pre">t</span></tt>. Zarisky topology). Moreover, if <tt class="docutils literal"><span class="pre">info?</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> then some information is displayed during the computations. See <em class="xref std std-ref">zeroSetSplit &lt;l&#8211;regular-triangular-set-category_zero-set-split&gt;`(``lp`</em>, <tt class="docutils literal"><span class="pre">true</span></tt>, <tt class="docutils literal"><span class="pre">info?</span></tt>). If <tt class="docutils literal"><span class="pre">lextri?</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> then the lexTriangular algorithm is called from the <a class="reference internal" href="LexTriangularPackage.html#l-lex-triangular-package"><em>LexTriangularPackage</em></a> constructor (see <em class="xref std std-ref">zeroSetSplit &lt;l&#8211;lex-triangular-package_zero-set-split&gt;`(``lp`</em>, <tt class="docutils literal"><span class="pre">false</span></tt>)). Otherwise, the triangular decomposition is computed directly from the input system by using the <a class="reference internal" href="RegularChain.html#l-regular-chain-zero-set-split"><em>zeroSetSplit</em></a> from <a class="reference internal" href="RegularChain.html#l-regular-chain"><em>RegularChain</em></a>.</dd>
</dl>
<dl class="docutils" id="index-18">
<dt><span class="spadfun">triangSolve</span>: <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="RegularChain.html#l-regular-chain"><em>RegularChain</em></a>(R, ls)</dt>
<dd><tt class="docutils literal"><span class="pre">triangSolve(lp)</span></tt> returns the same as <tt class="docutils literal"><span class="pre">triangSolve(lp,</span> <span class="pre">false,</span> <span class="pre">false)</span></tt></dd>
</dl>
<span class="target" id="l-zero-dimensional-solve-package-univariate-solve"></span><dl class="docutils" id="index-19">
<dt><span class="spadfun">univariateSolve</span>: (<a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> Record(complexRoots: <a class="reference internal" href="SparseUnivariatePolynomial.html#l-sparse-univariate-polynomial"><em>SparseUnivariatePolynomial</em></a> R, coordinates: <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R)</dt>
<dd><tt class="docutils literal"><span class="pre">univariateSolve(lp,</span> <span class="pre">info?)</span></tt> returns the same as <tt class="docutils literal"><span class="pre">univariateSolve(lp,</span> <span class="pre">info?,</span> <span class="pre">false,</span> <span class="pre">false)</span></tt>.</dd>
</dl>
<dl class="docutils" id="index-20">
<dt><span class="spadfun">univariateSolve</span>: (<a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> Record(complexRoots: <a class="reference internal" href="SparseUnivariatePolynomial.html#l-sparse-univariate-polynomial"><em>SparseUnivariatePolynomial</em></a> R, coordinates: <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R)</dt>
<dd><tt class="docutils literal"><span class="pre">univariateSolve(lp,</span> <span class="pre">info?,</span> <span class="pre">check?)</span></tt> returns the same as <tt class="docutils literal"><span class="pre">univariateSolve(lp,</span> <span class="pre">info?,</span> <span class="pre">check?,</span> <span class="pre">false)</span></tt>.</dd>
</dl>
<dl class="docutils" id="index-21">
<dt><span class="spadfun">univariateSolve</span>: (<a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>, <a class="reference internal" href="Boolean.html#l-boolean"><em>Boolean</em></a>) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> Record(complexRoots: <a class="reference internal" href="SparseUnivariatePolynomial.html#l-sparse-univariate-polynomial"><em>SparseUnivariatePolynomial</em></a> R, coordinates: <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R)</dt>
<dd><tt class="docutils literal"><span class="pre">univariateSolve(lp,</span> <span class="pre">info?,</span> <span class="pre">check?,</span> <span class="pre">lextri?)</span></tt> returns a univariate representation of the variety associated with <tt class="docutils literal"><span class="pre">lp</span></tt>. Moreover, if <tt class="docutils literal"><span class="pre">info?</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> then some information is displayed during the decomposition into regular chains. If <tt class="docutils literal"><span class="pre">check?</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> then the result is checked. See <em class="xref std std-ref">rur &lt;l&#8211;rational-univariate-representation-package_rur&gt;`(``lp`</em>, <tt class="docutils literal"><span class="pre">true</span></tt>). If <tt class="docutils literal"><span class="pre">lextri?</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> then the lexTriangular algorithm is called from the <a class="reference internal" href="LexTriangularPackage.html#l-lex-triangular-package"><em>LexTriangularPackage</em></a> constructor (see <em class="xref std std-ref">zeroSetSplit &lt;l&#8211;lex-triangular-package_zero-set-split&gt;`(``lp`</em>, <tt class="docutils literal"><span class="pre">false</span></tt>)). Otherwise, the triangular decomposition is computed directly from the input system by using the <a class="reference internal" href="RegularChain.html#l-regular-chain-zero-set-split"><em>zeroSetSplit</em></a> from <a class="reference internal" href="RegularChain.html#l-regular-chain"><em>RegularChain</em></a>.</dd>
</dl>
<dl class="docutils" id="index-22">
<dt><span class="spadfun">univariateSolve</span>: <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> Record(complexRoots: <a class="reference internal" href="SparseUnivariatePolynomial.html#l-sparse-univariate-polynomial"><em>SparseUnivariatePolynomial</em></a> R, coordinates: <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R)</dt>
<dd><tt class="docutils literal"><span class="pre">univariateSolve(lp)</span></tt> returns the same as <tt class="docutils literal"><span class="pre">univariateSolve(lp,</span> <span class="pre">false,</span> <span class="pre">false,</span> <span class="pre">false)</span></tt>.</dd>
</dl>
<dl class="docutils" id="index-23">
<dt><span class="spadfun">univariateSolve</span>: <a class="reference internal" href="RegularChain.html#l-regular-chain"><em>RegularChain</em></a>(R, ls) -&gt; <a class="reference internal" href="List.html#l-list"><em>List</em></a> Record(complexRoots: <a class="reference internal" href="SparseUnivariatePolynomial.html#l-sparse-univariate-polynomial"><em>SparseUnivariatePolynomial</em></a> R, coordinates: <a class="reference internal" href="List.html#l-list"><em>List</em></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><em>Polynomial</em></a> R)</dt>
<dd><tt class="docutils literal"><span class="pre">univariateSolve(ts)</span></tt> returns a univariate representation of <tt class="docutils literal"><span class="pre">ts</span></tt>. See <em class="xref std std-ref">rur &lt;l&#8211;rational-univariate-representation-package_rur&gt;`(``lp`</em>, <tt class="docutils literal"><span class="pre">true</span></tt>).</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h3><a href="index.html">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Categories.html">Categories</a></li>
<li class="toctree-l1"><a class="reference internal" href="Domains.html">Domains</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Packages.html">Packages</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="history.html" title="Commit History"
             >next</a> |</li>
        <li class="right" >
          <a href="XExponentialPackage.html" title="XExponentialPackage(R, VarSet, XPOLY)"
             >previous</a> |</li>
        <li><a href="index.html">FriCAS 1.2.7 API</a> &raquo;</li>
          <li><a href="Packages.html" >Packages</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014-2015, FriCAS Team.
    </div>
  </body>
</html>